import customtkinter as ctk
from tkinter import filedialog
import json
import numpy as np
import cv2
import os

# =============================================================================
# (Modell-Generierung)
# =============================================================================

def load_lens_profile(file_path):
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Datei nicht gefunden: {file_path}")

    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    if 'fisheye_params' in data:
        params = data['fisheye_params']
        camera_matrix = np.array(params['camera_matrix'])
        dist_coeffs = np.array(params['distortion_coeffs'])
        dims = data.get('calib_dimension', {'w': 1920, 'h': 1080})
        image_size = (dims['w'], dims['h'])
        return camera_matrix, dist_coeffs, image_size
    else:
        raise ValueError("Kein 'fisheye_params'-Abschnitt in JSON gefunden.")

def create_fov_mesh(camera_matrix, dist_coeffs, image_size, grid_density, depth):
    width, height = image_size
    grid_w, grid_h = grid_density

    # Vertices
    x = np.linspace(0, width - 1, grid_w)
    y = np.linspace(0, height - 1, grid_h)
    xv, yv = np.meshgrid(x, y)
    
    distorted_points = np.stack([xv, yv], axis=-1).reshape(-1, 2).astype(np.float32)
    distorted_points = np.expand_dims(distorted_points, axis=1)

    undistorted_points = cv2.fisheye.undistortPoints(
        distorted_points, camera_matrix, dist_coeffs
    )

    vertices = [[0, 0, 0]] # Ursprungspunkt
    for pt in undistorted_points:
        x_3d = pt[0][0] * depth
        y_3d = pt[0][1] * depth
        vertices.append([x_3d, y_3d, depth])
    
    vertices = np.array(vertices, dtype=np.float32)

    # Faces
    faces = []
    
    # Front Faces
    for i in range(grid_h - 1):
        for j in range(grid_w - 1):
            p1 = i * grid_w + j + 1
            p2 = i * grid_w + j + 2
            p3 = (i + 1) * grid_w + j + 1
            p4 = (i + 1) * grid_w + j + 2
            faces.append([p1, p2, p4])
            faces.append([p1, p4, p3])

    # Side Faces
    # Upper
    for j in range(grid_w - 1):
        p1 = j + 1
        p2 = j + 2
        faces.append([0, p1, p2])
    # Lower
    for j in range(grid_w - 1):
        p1 = (grid_h - 1) * grid_w + j + 1
        p2 = (grid_h - 1) * grid_w + j + 2
        faces.append([0, p2, p1]) # Umgekehrte Reihenfolge für korrekte Normalen
    # Left
    for i in range(grid_h - 1):
        p1 = i * grid_w + 1
        p2 = (i + 1) * grid_w + 1
        faces.append([0, p2, p1]) # Umgekehrte Reihenfolge
    # Right
    for i in range(grid_h - 1):
        p1 = i * grid_w + grid_w
        p2 = (i + 1) * grid_w + grid_w
        faces.append([0, p1, p2])

    faces = np.array(faces, dtype=np.int32)
    
    # Normals
    normals = np.zeros(vertices.shape, dtype=np.float32)
    for face in faces:
        v1, v2, v3 = vertices[face[0]], vertices[face[1]], vertices[face[2]]
        face_normal = np.cross(v2 - v1, v3 - v1)
        normals[face[0]] += face_normal
        normals[face[1]] += face_normal
        normals[face[2]] += face_normal
        
    norm = np.linalg.norm(normals, axis=1)[:, np.newaxis] + 1e-9
    normals /= norm
            
    return vertices, normals, faces


def write_obj_file(filepath, vertices, normals, faces):
    """Schreibt die Vertices, Normalen und Faces in eine .obj-Datei."""
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write("# 3D FOV Model generated by FOV-Generator\n")
        f.write("# Contains vertices (v), vertex normals (vn), and faces (f)\n")
        
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        
        for vn in normals:
            f.write(f"vn {vn[0]:.6f} {vn[1]:.6f} {vn[2]:.6f}\n")
        
        for face in faces:
            v1, v2, v3 = face[0] + 1, face[1] + 1, face[2] + 1
            f.write(f"f {v1}//{v1} {v2}//{v2} {v3}//{v3}\n")

# =============================================================================
#  2. GUI-ANWENDUNG (CustomTkinter mit .pack() Layout)
# =============================================================================

class App(ctk.CTk):
    def __init__(self):
        super().__init__()

        # --- Fensterkonfiguration ---
        self.title("FOVtoCAD - 3D FOV Model Generator")
        self.geometry("800x580")
        self.minsize(500, 450)

        # --- Farbthema ---
        self.BUTTON_COLOR = "#009999" # Cyan
        self.HOVER_COLOR = "#00BEBE"

        # --- Variablen für die Pfade ---
        self.input_path = ""
        self.output_path = ""

        # --- Widgets erstellen ---
        self.create_widgets()

    def create_widgets(self):
        
        # Container-Frame für alle Inhalte mit Padding
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(padx=20, pady=20, fill="both", expand=True)

        # --- Titel ---
        title_label = ctk.CTkLabel(main_frame, text="FOV 3D Model Generator - Create accurate 3D FOV Models from Lens Data", font=ctk.CTkFont(size=20, weight="bold"))
        title_label.pack(pady=(0, 20))

        # --- Frame für Datei-IO ---
        file_frame = ctk.CTkFrame(main_frame)
        file_frame.pack(fill="x", pady=5)

        input_button = ctk.CTkButton(file_frame, text="Load a Lensprofile... (.json)", command=self.select_input_file, fg_color=self.BUTTON_COLOR, hover_color=self.HOVER_COLOR)
        input_button.pack(pady=10, padx=10, fill="x")
        self.input_path_label = ctk.CTkLabel(file_frame, text="No file selected", text_color="gray", wraplength=480)
        self.input_path_label.pack(pady=(0, 10), padx=10)

        output_button = ctk.CTkButton(file_frame, text="Save 3D Model to...", command=self.select_output_file, fg_color=self.BUTTON_COLOR, hover_color=self.HOVER_COLOR)
        output_button.pack(pady=10, padx=10, fill="x")
        self.output_path_label = ctk.CTkLabel(file_frame, text="No output location selected", text_color="gray", wraplength=480)
        self.output_path_label.pack(pady=(0, 10), padx=10)

        # --- Frame für Parameter ---
        param_frame = ctk.CTkFrame(main_frame)
        param_frame.pack(fill="x", pady=10)
        param_frame.grid_columnconfigure(1, weight=1)

        depth_label = ctk.CTkLabel(param_frame, text="Model Depth:")
        depth_label.grid(row=0, column=0, padx=10, pady=10, sticky="w")
        self.depth_entry = ctk.CTkEntry(param_frame)
        self.depth_entry.insert(0, "100")
        self.depth_entry.grid(row=0, column=1, padx=10, pady=10, sticky="ew")

        density_label = ctk.CTkLabel(param_frame, text="Mesh Density (W x H):")
        density_label.grid(row=1, column=0, padx=10, pady=10, sticky="w")
        
        density_frame = ctk.CTkFrame(param_frame, fg_color="transparent")
        density_frame.grid(row=1, column=1, padx=10, pady=10, sticky="ew")
        density_frame.grid_columnconfigure((0,1), weight=1)
        self.density_w_entry = ctk.CTkEntry(density_frame)
        self.density_w_entry.insert(0, "50")
        self.density_w_entry.grid(row=0, column=0, padx=(0,5), sticky="ew")
        self.density_h_entry = ctk.CTkEntry(density_frame)
        self.density_h_entry.insert(0, "40")
        self.density_h_entry.grid(row=0, column=1, padx=(5,0), sticky="ew")

        # --- Generieren-Button und Status ---
        self.generate_button = ctk.CTkButton(main_frame, text="Generate 3D Model", command=self.generate_model, font=ctk.CTkFont(size=14, weight="bold"), state="disabled", fg_color=self.BUTTON_COLOR, hover_color=self.HOVER_COLOR)
        self.generate_button.pack(pady=10, ipady=10, fill="x")

        self.status_label = ctk.CTkLabel(main_frame, text="Ready. Please select file.", text_color="gray")
        self.status_label.pack(pady=(10, 0))

    def select_input_file(self):
        filepath = filedialog.askopenfilename(title="Select Lens Profile", filetypes=[("JSON Files", "*.json")])
        if filepath:
            self.input_path = filepath
            self.input_path_label.configure(text=os.path.basename(filepath), text_color="white")
            self.check_paths()

    def select_output_file(self):
        filepath = filedialog.asksaveasfilename(title="Save 3D Model to...", defaultextension=".obj", filetypes=[("Wavefront OBJ", "*.obj")])
        if filepath:
            self.output_path = filepath
            self.output_path_label.configure(text=os.path.basename(filepath), text_color="white")
            self.check_paths()
            
    def check_paths(self):
        if self.input_path and self.output_path:
            self.generate_button.configure(state="normal")
            self.status_label.configure(text="Ready to generate.", text_color="gray")

    def generate_model(self):
        try:
            self.status_label.configure(text="Reading parameters...", text_color="gray")
            depth = float(self.depth_entry.get())
            grid_w = int(self.density_w_entry.get())
            grid_h = int(self.density_h_entry.get())

            self.status_label.configure(text="Loading lens profile...", text_color="gray")
            mtx, dist, size = load_lens_profile(self.input_path)

            self.status_label.configure(text="Creating 3D mesh...", text_color="gray")
            v, vn, f = create_fov_mesh(mtx, dist, size, (grid_w, grid_h), depth)

            self.status_label.configure(text="Writing OBJ file...", text_color="gray")
            write_obj_file(self.output_path, v, vn, f)

            self.status_label.configure(text=f"Successfully saved: {os.path.basename(self.output_path)}", text_color="#00D100")

        except Exception as e:
            self.status_label.configure(text=f"Error: {e}", text_color="#FF4C4C")

# --- App Start ---
if __name__ == "__main__":
    ctk.set_appearance_mode("dark")
    app = App()
    app.mainloop()
